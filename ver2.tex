\documentclass[a4paper, titlepage]{article}

\usepackage{polski}
\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage{tabularx}
\usepackage{listings}
\usepackage{indentfirst}
\usepackage{caption}
\usepackage{float}
\usepackage{url}
\usepackage{dirtree}


\DeclareCaptionFont{white}{\color{white}}

\DeclareCaptionFormat{listing}{%

	\parbox{\textwidth}{\colorbox{gray}{\parbox{\textwidth}{#1#2#3}}\vskip-4pt}}

	\captionsetup[lstlisting]{format=listing,labelfont=white,textfont=white}

	\lstset{frame=lrb,xleftmargin=\fboxsep,xrightmargin=-\fboxsep}

	\setcounter{page}{0}

	\begin{document}

	\author{Mateusz Olczak}

	\title{Webowa aplikacja do przeprowadzania testów -- Praca Inżynierska}
	
	\maketitle
	\newpage


	\section{\textbf{Wstęp}}

	W dzisiejszych czasach, dzięki nowym technologiom oraz rosnącym przepustowościom pasma internetowego dostępnym dla zwykłego użytkownika, coraz częściej odchodzi się od projektowania aplikacji desktopowych na rzecz aplikacji webowych. Aplikacje webowe są w pełni niezależne od systemu operacyjnego, zazwyczaj cechują się o wiele mniejszymi wymaganiami sprzętowymi (ponieważ przeważająca część logiki, wykonywana jest po stronie serwera). Ponadto, dzięki całej gamie framework' ów pomagających w tworzeniu widokowej wartswy aplikacji, systemy tworzone jako aplikacje webowe są o wiele bardziej estetyczne, ergonomiczne dla użytkownika, a dla twórcy oprogramowania - łatwiejsze do modyfikacji. 
	Jak widać, istnieje wiele powodów, dla których warto porzucić aplikacje desktopowe na rzecz przenośnych systemów przeglądarkowych. Dlatego też realizowana przeze mnie aplikacja reprezentuje nowy nurt.
	

	\subsection{Cele}
	Głównym założeniem projektu było stworzenie aplikacji webowej, której zadaniem było umożliwienie tworzenia testów jednokrotnego wyboru oraz generowanie testów z wcześniej utworzonych pytań.
	Ponadto, dużą uwagę nałożono na bezpieczeństwo oraz responsywność systemu. Aplikacja miała być intuicyjna, aby każdy student mógł rozwiązać test, bez konieczności wcześniejszego wprowadzenia do korzystania z systemu. 
	\subsection{Zakres pracy}
	W mojej pracy zawarłem podstawowe informacje o działaniu systemu, opis funkcjonalności, wykorzystanych technologii oraz instrukcję korzystania z systemu.
	
	\section{\textbf{Teoria}}
	\subsection{Spis treści}
	\subsection{Prawa autorskie}
	\subsection{Odpowiedzialność dyplomanta}
	\subsection{Zastosowane algorytmy}
	Jednym z założeń projektowych było opracowanie metody generowania losowych zestawów pytań, gdzie pytania charakteryzowały się zróżnicowanym poziomem trudności. Dodatkową trudnością było wygenerowanie testów na podstawie pytań o bardzo zróżnicowanej łącznej sumie punktów. Fakt ten uniemożliwiał określenie apriori, jaka powinna być wartość, do której zmierzałby algorytm symulowanego wyżarzania (który postanowiłem zastosować do rozwiązania problemu). Moja implementacja algorytmu opiera się na wyznaczaniu kolejnych zestawów pytań na podstawie losowo wygenerowanego pierwowzoru. Ponieważ pytania podzielone są na grupy kursów jakich dotyczą, należało tak dopasować cały proces generowania pytań, aby uwzględnić w nim wszystkie niżej wymienione założenia:
	\begin{itemize}
	\item Niepowtarzalność pytań w teście.
	\item Testy składające się z pytań o różnej wartości punktowej (odpowiadającej zróżnicowanemu poziomowi trudności).
	\item Testy zawierają pytania jedynie z jednej grupy.
	\item Każdy ze studentów rozwiązujących test z danej grupy powinien otrzymać zestaw pytań o takiej samej, łącznej ilości punktów.
	\item Test powinien składać się z około 30 pytań
	\end{itemize}
	
Poniżej znajduje się opis mojego podejścia do rozwiązania problemu:

	\begin{itemize}
	\item Aby dostosować granicę punktową do jakiej powinien zmierzać algorytm symulowanego wyżarzania, przed rozpoczęciem właściwego działania aplikacji (polegajęcego na serwowaniu studentom zestawów pytań), generowanych jest kilka losowych zestawów pytań, a następnie obliczana jest średnia z maksymalnej ilości punktów, jaką można uzyskać z każdego z nich. Proces powtarzany jest dla każdej grupy pytań
	\item Obliczenia te dokonywane są cyklicznie, w zaplanowanych godzinach. Do implementacji tego rozwiązania użyłem biblioteki Quartz. Pozwala ona na planownaie zadań, jakie mają być realizowane na serwerze. Wybrane przeze mnie uznałem za optymalne, ponieważ pozwala ono w prosty sposób, uaktualniać obliczane wartości, a ponad to nie łamie zasad czystego kodu. Jednak podejście to ma niesie za sobą pewne komplikacje, w bazie pojawiają się pytania, które mogą nie być uwzględnione w obliczeniach, ponieważ, zostały utworzone, na krótko przed rozpoczęciem egazminu, przez co nie zostały uwzględnione w procesie obliczania średnich wartości punktowych. W celu rozwiązania tego problemu, rozszeżyłem tabelę przechowującą informacje o pytaniach o dodatkową kolumnę, określającą czy dane pytanie zostało już zweryfikowane. Implikuje to wprowadzenie dodatkowego sprawdzenia przy generowaniu testów, które sprawdzałoby status pytania. 
\\Innymi rozważanymi przeze mnie rozwiązaniami były:
		\begin{itemize}
        \item Dokonywanie obliczeń przy wylogowywaniu prowadzącego z systemu, wadą tego podejścia jest złamanie zasad czystego kodu, ponieważ jedna czynność (wylogownaie) wiązałoby się z dodatkową, ukrytą funkcjonalnością. Do zalet należy niewątpliwie zaliczyć, zapewnienie pewności ponownego przeliczenia wartości punktowych oraz stosunkowo dobra wydajność rozwiązania. 
		\item Obliczanie średniej wartości punktowej po dodaniu każdego z pytań (wadą takiego rozwiązania byłoby nadmierne obciążenie systemu, natomiast zaletą, pewność, że wartości będą zaktualizowane)
		\item Aktualizacja wartości wywoływana manualnie przez użytkownika(zalety: najmniejsze obciążenie dla systemu, wady: duże prawdopodobieństwo niedokonania aktualizacji, spowodowane czynnikiem ludzkim (prowadzący mógłby zapomnieć zaktualizować średnie wartości))
		\end{itemize}
	\item Kiedy student, w celu rozwiązania testu, wysyła żądanie do serwera, rozpoczyna się proces wykorzystujący algorytm symulowanego wyżarzania:
		\begin{itemize}
		\item Metoda realizująca algorytm parametryzowana jest przez dwa argumenty: ilość pytań (określoną wcześniej) oraz wartość punktów, do której powinien zmierzać algorytm (wartość ta określana jest na podstawie wcześniej wygenerowanych sum punktów oraz kategorii pytań jaką wybrał student.
		\item Po każdorazowym dodaniu pytania wytypowanego przez algorytm, dokonuje się sprawdzenia, czy pytanie to nie jest już zawarte w aktualnie przygotowywanym zestawie
		\item Ostatnim krokiem, jest wysłanie do studenta listy pytań
        \subsection{Szczegółowy opis implementacji algorytmu symulowanego wyżarzania}
        \subsection{Aspekt bezpieczeństwa}
        W celu spełnieniu kolejnego z głównych założeń projektu - zapewnienia bezpieczeństwa w aplikacji, zastosowałem moduł wchodzący w skład projektu Spring, mowa tu o module "Spring Security". Wykorzystałem możliwości wyżej wymienionego modułu, do powiązania procesu logowania i rejestrowania użytkowników z bazą danych. 
        \\ Konto każdego z użytkowników, tworzone jest przez administratorów, z założenia jest unikatowe (podczas tworzenia nowego użytkownika, dokonywane jest sprawdzenie, czy użytkownik o danym loginie istnieje już w bazie danych. Podczas tworzenia konta, użytkownik otrzymuje jedną spośród trzech roli:
        \begin{itemize}
        \item Prowadzący
        \item Administrator
        \item Student
        \end{itemize}
        Opis roli przedstawiony jest w punkcie ****** w mojej pracy.
        \\ Każdy użytkownik otrzymuje hasło, które jest wprowadzane przez administratora, hasło to jest zapisywane w bazie danych w postaci zakodowanej algorytmeme md5. W przyszłośći, hasła mogą być przydzielane w inny, bardziej zaawansowany sposób. Opis takiego rozwiązania można znaleźć w punkcie ***** w tej pracy.
		\end{itemize}
        
        \subsection{Motywacja wykorzystania danego sposobu zabezpieczenia aplikacji oraz porównanie z innymi możliwymi rozwązaniami}
	\end{itemize}
    
    
    \section{Baza danych}
    \subsection{Wykorzystany}
    \subsection{Schemat bazy danych}
    
    
\end{document}

